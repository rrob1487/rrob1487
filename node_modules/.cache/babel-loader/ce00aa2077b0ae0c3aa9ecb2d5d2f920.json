{"ast":null,"code":"var _jsxFileName = \"/home/robbie/School/react_resume_published/src/Components/Projects.js\";\nimport React, { Component } from \"react\";\nimport { MDBContainer, MDBCol, MDBRow } from \"mdbreact\";\nimport BasicCard from \"./BasicCard\";\nexport const ProjectObjects = [{\n  ProjectName: 'MIDI Board',\n  ProjectDescription: \"I built this project the summer after my first year of college. It was my first project written in a language other than Java, and it was my first attempt at using any type of microcontroller. For this project, I created a 16-button MIDI keyboard, capable of communicating with Ableton and other MIDI enabled software. The purpose of the keyboard is to act as a drum rack so that users can play sounds and loops at the press of a button. \",\n  Tools: \"Arcade buttons were used for the inputs, wood for the base, and plastic as the shell, which I molded and shaped using heat. For development I used the Arduino IDE and an Arduino Uno board. A Hairless-MIDISerial software was used as a bridge to test the code before using Atmel Flip to flash the board and make it a fully functional MIDI device.\",\n  Lessons: \"There were multiple challenges associated with this project including software debugging and base/shell design issues.  The lesson learned from this project was how to problem solve and improvise. This project challenged my dedication but my ability to fight through the adversity and setbacks and complete my goals is something that I am proud of even today. If I were to do this project again, I would modify hardware and perhaps choose different components. Based on my experience, I would use an Arduino Mega so that I have open pins for lights and potentiometers. I would also choose different design materials for the shell and base that were lighter weight and more flexible. And lastly, I wouldn’t use solid-core wire, as it is brittle and prone to breaking.\",\n  DateFinished: \"Aug 2016\",\n  Link: \"Coming Soon\",\n  Pictures: [\"midiboard1.jpg\", 'me.jpg']\n}, {\n  ProjectName: 'IoT Drapes',\n  ProjectDescription: \"After the success with my MIDI board project, I attempted another project using a micro controller device. This project was a window covering that could be controlled from my phone/laptop. The end design included interfacing the window covering with an alarm clock so that the blackout curtains would retract when the alarm sounded, and the sun would shine in when it was time to get up. \",\n  Tools: \"For this project I used a Wi-Fi enabled micro controller, a 6V continuous rotation servo motor, a long dowel as the “curtain rod”, and several yards of blackout fabric. The fabric was wrapped around and attached to the dowel which was mounted above the window on custom made mounting hardware which allowed the entire system to rotate freely.  One end of the dowel was attached to the servo motor. As the servo would spin, the fabric would wrap around the dowel, allowing more or less light through the window, depending on whether the fabric was going up or down. I was able to find a GitHub library that had Arduino code to host a web server that functioned properly on my hardware, and from there I just added the code to parse the server requests, and move the motor accordingly.\",\n  Lessons: \"This project presented the most learning opportunities, including basic household DIY tips, sewing tips and networking protocols.  The weight of the window covering presented challenges in keeping it on the wall; a better mounting system would be critical in a redesign.  Initially, to get the window covering functioning, I parsed the URL of HTTP GET requests and I did not design a GUI or user interface.  To remotely control the window covering movement I had to submit requests to the IP (which was not static) followed by a number between 0 and 100, which corresponded to the percent of window to cover. For example, if I wanted to put the shades all the way down, I would type 10.10.10.24/100 into my browser and it would start spinning.  This was problematic, mostly because of a lack of input sanitation.   This “buggy” system led to the window covering randomly activating, often, in the middle of the night. Overall, the window covering did function, and could be deployed remotely.  However, the physical design, coupled with the unsophisticated electronic interface, led to less than optimal operation.  If I were to design this project now, a total redesign of the hardware and software would result, but the main takeaways from this project are that a basic understanding of networking is crucial for any IoT devices and prototypes of the hardware would shed light on physical limitations prior to launching.\",\n  DateFinished: \"Aug 2017\",\n  Link: \"Coming Soon\"\n}, {\n  ProjectName: 'Alarm Clock',\n  ProjectDescription: \"I completed this project for my Introduction to Operating Systems class. The alarm clock was a Raspberry Pi with a touchscreen and custom GUI. The interface allowed the alarm clock to show the current time, set an alarm, and turn off the screen so that the light from the display did not keep me awake. It also had a microphone and a speaker, and it ran the open source Google Assistant library in the background\",\n  Tools: \"The user interface was a Java application that I created using the native JSwing library. The touchscreen came with its own software which was used because of the ease of set up. To use the Google Assistant library, I set up a Google Cloud Account and configured the proper authentication tokens. Overall, getting everything to work independently presented very few challenges.\",\n  Lessons: \"Like many things in life, this project was great in theory, but not functional in practice. The software for the touchscreen and the Google Assistant required different versions of Raspbian and as a result, the libraries were incompatible, and I was forced to demonstrate the project in two different parts, hot swapping micro SD cards to show the different pieces. This issue could have been addressed by using a different touchscreen, or by using a HDMI enabled screen and some additional hardware buttons, but due to time constraints, I wasn’t able to procure the additional hardware necessary. This project was a great lesson in the importance of interoperability and system testing, and if I were to do it again, I would verify library compatibility beforehand. \",\n  DateFinished: \"Dec 2017\",\n  Link: \"Coming Soon\"\n}, {\n  ProjectName: 'Jukebox',\n  ProjectDescription: \"This was a semester long group project for my CIS 320 Project Management course. Because the project proposal that I submitted was chosen, I was given the Project Manager role.  As Project Manager scope and cost were my responsibilities. The goal of this project was to create a LAN jukebox that allows anyone to visit a website and add songs to a FIFO queue. The device would then use a python script to download the songs and play them in the order they were added to the queue on a common speaker.\",\n  Tools: \"A Spring Boot webserver was used with a React frontend on a Raspberry Pi. The front end used the Spotify Search API to help users find songs and the back end parsed the URL of the song request and used an external library to download the file needed. The Raspberry Pi was set up with a static IP and could be attached to a set of speakers with either Bluetooth, Aux, or even HDMI, if you wanted to play music from a TV/Monitor. \",\n  Lessons: \"This project went very smoothly. At the start my team understood all the different challenges that we would have to conquer, so we were prepared to quickly solve many of the issues as they arose. This was not my first time using React, so I had experience with it and provided most of the support on that part of the project.  The lack of learning curve ensured that the set up was quickly accomplished.  The most challenging task was getting the user verification for Spotify set up properly.\",\n  DateFinished: \"Nov 2018\",\n  Link: \"Coming Soon\"\n}, {\n  ProjectName: 'Roller Ball',\n  ProjectDescription: \"E\",\n  Tools: \"\",\n  Lessons: \"\",\n  DateFinished: \"\",\n  Link: \"\"\n}, {\n  ProjectName: 'Roller Ball',\n  ProjectDescription: \"E\",\n  Tools: \"\",\n  Lessons: \"\",\n  DateFinished: \"\",\n  Link: \"\"\n}, {\n  ProjectName: 'Roller Ball',\n  ProjectDescription: \"E\",\n  Tools: \"\",\n  Lessons: \"\",\n  DateFinished: \"\",\n  Link: \"\"\n}, {\n  ProjectName: 'Roller Ball',\n  ProjectDescription: \"E\",\n  Tools: \"\",\n  Lessons: \"\",\n  DateFinished: \"\",\n  Link: \"\"\n}];\nexport class Projects extends Component {\n  render() {\n    return React.createElement(MDBContainer, {\n      fluid: true,\n      className: \"elegant-color-dark\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 78\n      },\n      __self: this\n    }, React.createElement(MDBRow, {\n      style: {\n        height: \"15vh\"\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 80\n      },\n      __self: this\n    }, React.createElement(MDBCol, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 81\n      },\n      __self: this\n    }, React.createElement(MDBContainer, {\n      className: \"flex-center\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 82\n      },\n      __self: this\n    }, React.createElement(\"h1\", {\n      className: \"text-light \",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 83\n      },\n      __self: this\n    }, \"My Projects\"))), React.createElement(MDBCol, {\n      size: \"9\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 86\n      },\n      __self: this\n    })), React.createElement(MDBRow, {\n      center: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 88\n      },\n      __self: this\n    }, React.createElement(MDBCol, {\n      size: \"11\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 89\n      },\n      __self: this\n    }, ProjectObjects.map((proj, index) => React.createElement(BasicCard, {\n      className: \"z-depth-5\",\n      index: index,\n      title: proj.ProjectName,\n      description: proj.ProjectDescription,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 92\n      },\n      __self: this\n    })))));\n  }\n\n}","map":{"version":3,"sources":["/home/robbie/School/react_resume_published/src/Components/Projects.js"],"names":["React","Component","MDBContainer","MDBCol","MDBRow","BasicCard","ProjectObjects","ProjectName","ProjectDescription","Tools","Lessons","DateFinished","Link","Pictures","Projects","render","height","map","proj","index"],"mappings":"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","sourcesContent":["import React, {Component} from \"react\"\nimport {MDBContainer, MDBCol, MDBRow} from \"mdbreact\"\nimport BasicCard from \"./BasicCard\"\n\nexport const ProjectObjects = [\n    {\n    ProjectName: 'MIDI Board',\n    ProjectDescription: \"I built this project the summer after my first year of college. It was my first project written in a language other than Java, and it was my first attempt at using any type of microcontroller. For this project, I created a 16-button MIDI keyboard, capable of communicating with Ableton and other MIDI enabled software. The purpose of the keyboard is to act as a drum rack so that users can play sounds and loops at the press of a button. \",\n    Tools: \"Arcade buttons were used for the inputs, wood for the base, and plastic as the shell, which I molded and shaped using heat. For development I used the Arduino IDE and an Arduino Uno board. A Hairless-MIDISerial software was used as a bridge to test the code before using Atmel Flip to flash the board and make it a fully functional MIDI device.\",\n    Lessons: \"There were multiple challenges associated with this project including software debugging and base/shell design issues.  The lesson learned from this project was how to problem solve and improvise. This project challenged my dedication but my ability to fight through the adversity and setbacks and complete my goals is something that I am proud of even today. If I were to do this project again, I would modify hardware and perhaps choose different components. Based on my experience, I would use an Arduino Mega so that I have open pins for lights and potentiometers. I would also choose different design materials for the shell and base that were lighter weight and more flexible. And lastly, I wouldn’t use solid-core wire, as it is brittle and prone to breaking.\",\n    DateFinished: \"Aug 2016\",\n    Link: \"Coming Soon\",\n    Pictures: [\"midiboard1.jpg\", 'me.jpg'],\n    },\n    {\n    ProjectName: 'IoT Drapes',\n    ProjectDescription: \"After the success with my MIDI board project, I attempted another project using a micro controller device. This project was a window covering that could be controlled from my phone/laptop. The end design included interfacing the window covering with an alarm clock so that the blackout curtains would retract when the alarm sounded, and the sun would shine in when it was time to get up. \",\n    Tools: \"For this project I used a Wi-Fi enabled micro controller, a 6V continuous rotation servo motor, a long dowel as the “curtain rod”, and several yards of blackout fabric. The fabric was wrapped around and attached to the dowel which was mounted above the window on custom made mounting hardware which allowed the entire system to rotate freely.  One end of the dowel was attached to the servo motor. As the servo would spin, the fabric would wrap around the dowel, allowing more or less light through the window, depending on whether the fabric was going up or down. I was able to find a GitHub library that had Arduino code to host a web server that functioned properly on my hardware, and from there I just added the code to parse the server requests, and move the motor accordingly.\",\n    Lessons: \"This project presented the most learning opportunities, including basic household DIY tips, sewing tips and networking protocols.  The weight of the window covering presented challenges in keeping it on the wall; a better mounting system would be critical in a redesign.  Initially, to get the window covering functioning, I parsed the URL of HTTP GET requests and I did not design a GUI or user interface.  To remotely control the window covering movement I had to submit requests to the IP (which was not static) followed by a number between 0 and 100, which corresponded to the percent of window to cover. For example, if I wanted to put the shades all the way down, I would type 10.10.10.24/100 into my browser and it would start spinning.  This was problematic, mostly because of a lack of input sanitation.   This “buggy” system led to the window covering randomly activating, often, in the middle of the night. Overall, the window covering did function, and could be deployed remotely.  However, the physical design, coupled with the unsophisticated electronic interface, led to less than optimal operation.  If I were to design this project now, a total redesign of the hardware and software would result, but the main takeaways from this project are that a basic understanding of networking is crucial for any IoT devices and prototypes of the hardware would shed light on physical limitations prior to launching.\",\n    DateFinished: \"Aug 2017\",\n    Link: \"Coming Soon\",\n    },\n    {\n    ProjectName: 'Alarm Clock',\n    ProjectDescription: \"I completed this project for my Introduction to Operating Systems class. The alarm clock was a Raspberry Pi with a touchscreen and custom GUI. The interface allowed the alarm clock to show the current time, set an alarm, and turn off the screen so that the light from the display did not keep me awake. It also had a microphone and a speaker, and it ran the open source Google Assistant library in the background\",\n    Tools: \"The user interface was a Java application that I created using the native JSwing library. The touchscreen came with its own software which was used because of the ease of set up. To use the Google Assistant library, I set up a Google Cloud Account and configured the proper authentication tokens. Overall, getting everything to work independently presented very few challenges.\",\n    Lessons: \"Like many things in life, this project was great in theory, but not functional in practice. The software for the touchscreen and the Google Assistant required different versions of Raspbian and as a result, the libraries were incompatible, and I was forced to demonstrate the project in two different parts, hot swapping micro SD cards to show the different pieces. This issue could have been addressed by using a different touchscreen, or by using a HDMI enabled screen and some additional hardware buttons, but due to time constraints, I wasn’t able to procure the additional hardware necessary. This project was a great lesson in the importance of interoperability and system testing, and if I were to do it again, I would verify library compatibility beforehand. \",\n    DateFinished: \"Dec 2017\",\n    Link: \"Coming Soon\",\n    },\n    {\n    ProjectName: 'Jukebox',\n    ProjectDescription: \"This was a semester long group project for my CIS 320 Project Management course. Because the project proposal that I submitted was chosen, I was given the Project Manager role.  As Project Manager scope and cost were my responsibilities. The goal of this project was to create a LAN jukebox that allows anyone to visit a website and add songs to a FIFO queue. The device would then use a python script to download the songs and play them in the order they were added to the queue on a common speaker.\",\n    Tools: \"A Spring Boot webserver was used with a React frontend on a Raspberry Pi. The front end used the Spotify Search API to help users find songs and the back end parsed the URL of the song request and used an external library to download the file needed. The Raspberry Pi was set up with a static IP and could be attached to a set of speakers with either Bluetooth, Aux, or even HDMI, if you wanted to play music from a TV/Monitor. \",\n    Lessons: \"This project went very smoothly. At the start my team understood all the different challenges that we would have to conquer, so we were prepared to quickly solve many of the issues as they arose. This was not my first time using React, so I had experience with it and provided most of the support on that part of the project.  The lack of learning curve ensured that the set up was quickly accomplished.  The most challenging task was getting the user verification for Spotify set up properly.\",\n    DateFinished: \"Nov 2018\",\n    Link: \"Coming Soon\",\n    },\n    {\n    ProjectName: 'Roller Ball',\n    ProjectDescription: \"E\",\n    Tools: \"\",\n    Lessons: \"\",\n    DateFinished: \"\",\n    Link: \"\",\n    },\n    {\n    ProjectName: 'Roller Ball',\n    ProjectDescription: \"E\",\n    Tools: \"\",\n    Lessons: \"\",\n    DateFinished: \"\",\n    Link: \"\",\n    },\n    {\n    ProjectName: 'Roller Ball',\n    ProjectDescription: \"E\",\n    Tools: \"\",\n    Lessons: \"\",\n    DateFinished: \"\",\n    Link: \"\",\n    },\n    {\n    ProjectName: 'Roller Ball',\n    ProjectDescription: \"E\",\n    Tools: \"\",\n    Lessons: \"\",\n    DateFinished: \"\",\n    Link: \"\",\n    },\n\n\n    ];\n\nexport class Projects extends Component {\n    render() {\n        return (\n            <MDBContainer fluid className=\"elegant-color-dark\">\n                {/*Header*/}\n                <MDBRow style={{height: \"15vh\"}}>\n                    <MDBCol>\n                        <MDBContainer className=\"flex-center\">\n                            <h1 className=\"text-light \">My Projects</h1>\n                        </MDBContainer>\n                    </MDBCol>\n                    <MDBCol size=\"9\"/>\n                </MDBRow>\n                <MDBRow center>\n                    <MDBCol size=\"11\">\n                        {\n                        ProjectObjects.map((proj, index) => (\n                            <BasicCard className=\"z-depth-5\"\n                                index={index}\n                                title={proj.ProjectName}\n                                description={proj.ProjectDescription    }\n                            />\n                        ))}\n                    </MDBCol>\n                </MDBRow>\n            </MDBContainer>)\n    }\n}\n\n"]},"metadata":{},"sourceType":"module"}